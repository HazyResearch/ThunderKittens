__global__ void test_reg_transpose_ker(const bf16 *input, bf16 *output) {
    rt_bf<HEIGHT, WIDTH> reg_tile;
    rt_bf<WIDTH, HEIGHT> reg_tile_transpose;

    load(reg_tile, input, COLS);
    transpose_sep(reg_tile_transpose, reg_tile);
    store(output, reg_tile_transpose, ROWS);
}
bool test_reg_transpose() {
    // initialize
    bf16 *d_i, *d_o;
    std::vector<float> i_ref(SIZE);
    std::vector<float> o_ref(SIZE);
    initialize(&d_i, &d_o, i_ref, o_ref);
    // run kernel
    cudaFuncSetAttribute(test_reg_transpose_ker, cudaFuncAttributeMaxDynamicSharedMemorySize, 100000);
    test_reg_transpose_ker<<<1, 128, 100000>>>(d_i, d_o);
    // fill in correct results on cpu
    for(int i = 0; i < ROWS; i++) {
        for(int j = 0; j < COLS; j++) {
            o_ref[i+j*ROWS] = i_ref[i*COLS+j];
        }
    }
    // check and cleanup
    bool passed = validate(d_i, d_o, i_ref, o_ref, "reg_transpose_ker");
    return passed;
}

// layout 1 test loads in row format, swaps, and writes in col format.
__global__ void test_swap_reg_layout_row2col_global_ker(const bf16 *input, bf16 *output) {
    rt_bf<HEIGHT, WIDTH> reg_tile;
    load(reg_tile, input, COLS);
    rt_bf<HEIGHT, WIDTH, ducks::rt_layout::col> &reg_tile_col = swap_layout_inplace(reg_tile);
    store(output, reg_tile_col, COLS);
}
bool test_swap_reg_layout_row2col_global() {
    // initialize
    bf16 *d_i, *d_o;
    std::vector<float> i_ref(SIZE);
    std::vector<float> o_ref(SIZE);
    initialize(&d_i, &d_o, i_ref, o_ref);
    // run kernel
    cudaFuncSetAttribute(test_swap_reg_layout_row2col_global_ker, cudaFuncAttributeMaxDynamicSharedMemorySize, 100000);
    test_swap_reg_layout_row2col_global_ker<<<1, 32, 100000>>>(d_i, d_o);
    // fill in correct results on cpu
    for(int i = 0; i < SIZE; i++) o_ref[i] = i_ref[i];
    // check and cleanup
    bool passed = validate(d_i, d_o, i_ref, o_ref, "swap_reg_layout_row2col_global");
    return passed;
}

// layout 2 test loads in col format, swaps, and writes in row format.
__global__ void test_swap_reg_layout_col2row_global_ker(const bf16 *input, bf16 *output) {
    rt_bf<HEIGHT, WIDTH, ducks::rt_layout::col> reg_tile;
    load(reg_tile, input, COLS);
    rt_bf<HEIGHT, WIDTH> &reg_tile_row = swap_layout_inplace(reg_tile);
    store(output, reg_tile_row, COLS);
}
bool test_swap_reg_layout_col2row_global() {
    // initailize
    bf16 *d_i, *d_o;
    std::vector<float> i_ref(SIZE);
    std::vector<float> o_ref(SIZE);
    initialize(&d_i, &d_o, i_ref, o_ref);
    // run kernel
    cudaFuncSetAttribute(test_swap_reg_layout_col2row_global_ker, cudaFuncAttributeMaxDynamicSharedMemorySize, 100000);
    test_swap_reg_layout_col2row_global_ker<<<1, 32, 100000>>>(d_i, d_o);
    // fill in correct results on cpu
    for(int i = 0; i < SIZE; i++) o_ref[i] = i_ref[i];
    // check and cleanup
    bool passed = validate(d_i, d_o, i_ref, o_ref, "swap_reg_layout_col2row_global");
    return passed;
}

// layout 1 test loads in row format, swaps, and writes in col format.
__global__ void test_swap_reg_layout_row2col_shared_ker(const bf16 *input, bf16 *output) {

    extern __shared__ __align__(16) int __shm[]; // this is the CUDA shared memory
    shared_allocator al = shared_allocator::create_allocator((int*)&__shm[0]); 

    rt_bf<HEIGHT, WIDTH> reg_tile;

    auto block = cooperative_groups::this_thread_block();
    __shared__ cuda::barrier<cuda::thread_scope::thread_scope_block> barrier;
    if (threadIdx.x == 0) {init(&barrier, block.size());}
    block.sync();
    
    st_bf<HEIGHT, WIDTH> &smem_tile = al.allocate<st_bf<HEIGHT, WIDTH>>();

    block.sync();
    load_async(smem_tile, input, COLS, barrier);
    barrier.arrive_and_wait();
    load(reg_tile, smem_tile);
    rt_bf<HEIGHT, WIDTH, ducks::rt_layout::col> &reg_tile_col = swap_layout_inplace(reg_tile);
    store(smem_tile, reg_tile_col);

    store_async(output, smem_tile, COLS, barrier);
    barrier.arrive_and_wait();
}
bool test_swap_reg_layout_row2col_shared() {
    // initailize
    bf16 *d_i, *d_o;
    std::vector<float> i_ref(SIZE);
    std::vector<float> o_ref(SIZE);
    initialize(&d_i, &d_o, i_ref, o_ref);
    // run kernel
    cudaFuncSetAttribute(test_swap_reg_layout_row2col_shared_ker, cudaFuncAttributeMaxDynamicSharedMemorySize, 100000);
    test_swap_reg_layout_row2col_shared_ker<<<1, 32, 100000>>>(d_i, d_o);
    // fill in correct results on cpu
    for(int i = 0; i < SIZE; i++) o_ref[i] = i_ref[i];
    // check and cleanup
    bool passed = validate(d_i, d_o, i_ref, o_ref, "swap_reg_layout_row2col_shared");
    return passed;
}

// layout 2 test loads in col format, swaps, and writes in row format.
__global__ void test_swap_reg_layout_col2row_shared_ker(const bf16 *input, bf16 *output) {

    extern __shared__ __align__(16) int __shm[]; // this is the CUDA shared memory
    shared_allocator al = shared_allocator::create_allocator((int*)&__shm[0]); 

    rt_bf<HEIGHT, WIDTH, ducks::rt_layout::col> reg_tile;

    auto block = cooperative_groups::this_thread_block();
    __shared__ cuda::barrier<cuda::thread_scope::thread_scope_block> barrier;
    if (threadIdx.x == 0) {init(&barrier, block.size());}
    block.sync();
    
    st_bf<HEIGHT, WIDTH> &smem_tile = al.allocate<st_bf<HEIGHT, WIDTH>>();

    block.sync();
    load_async(smem_tile, input, COLS, barrier);
    barrier.arrive_and_wait();
    load(reg_tile, smem_tile);
    rt_bf<HEIGHT, WIDTH> &reg_tile_row = swap_layout_inplace(reg_tile);
    store(smem_tile, reg_tile_row);

    store_async(output, smem_tile, COLS, barrier);
    barrier.arrive_and_wait();
}
bool test_swap_reg_layout_col2row_shared() {
    // initailize
    bf16 *d_i, *d_o;
    std::vector<float> i_ref(SIZE);
    std::vector<float> o_ref(SIZE);
    initialize(&d_i, &d_o, i_ref, o_ref);
    // run kernel
    cudaFuncSetAttribute(test_swap_reg_layout_col2row_shared_ker, cudaFuncAttributeMaxDynamicSharedMemorySize, 100000);
    test_swap_reg_layout_col2row_shared_ker<<<1, 32, 100000>>>(d_i, d_o);
    // fill in correct results on cpu
    for(int i = 0; i < SIZE; i++) o_ref[i] = i_ref[i];
    // check and cleanup
    bool passed = validate(d_i, d_o, i_ref, o_ref, "swap_reg_layout_col2row_shared");
    return passed;
}

int rt_layout_tests() {
    std::cout << " ----- Starting register layout tests! -----" << std::endl;
    int failures = 0;
    failures += !test_reg_transpose();
    failures += !test_swap_reg_layout_row2col_global();
    failures += !test_swap_reg_layout_col2row_global();
    failures += !test_swap_reg_layout_row2col_shared();
    failures += !test_swap_reg_layout_col2row_shared();
    return failures;
}