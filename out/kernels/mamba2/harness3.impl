#define ONEAPI_BACKEND_LEVEL_ZERO_EXT
#define DPCT_PROFILING_ENABLED
#include <sycl/sycl.hpp>
#include <dpct/dpct.hpp>
#include <iostream>
#include <random>
#include <chrono>
#include <cmath>

#include <sycl/ext/intel/math.hpp>

// Constants matching the original configuration
constexpr int ATTN_B = 16;  // Batch size
constexpr int ATTN_H = 16;  // Number of heads
constexpr int ATTN_N = 1024;  // Sequence length
constexpr int ATTN_D = 64;  // Head dimension
constexpr int ATTN_G = 1;   // Number of groups
constexpr int NUM_ITERATIONS = 2000;  // Number of test iterations

constexpr int BLOCK_SIZE = prototype::detail::NUM_THREADS_v<mamba2_fwd_template>;

// Helper function for CUDA error checking
/*
DPCT1001:583: The statement could not be removed.
*/
/*
DPCT1000:584: Error handling if-stmt was detected but could not be rewritten.
*/
/*
DPCT1009:585: SYCL reports errors using exceptions and does not use error codes.
Please replace the "get_error_string_dummy(...)" with a real error-handling
function.
*/
#define CHECK_CUDA(call) do {                                                  \
        dpct::err0 err = call;                                                 \
        if (err != 0) {                                                        \
            std::cerr << "CUDA error in file '" << __FILE__ << "' line "       \
                      << __LINE__ << ": " << dpct::get_error_string_dummy(err) \
                      << std::endl;                                            \
            exit(EXIT_FAILURE);                                                \
        }                                                                      \
    } while (0)

struct TestResults {
    int num_nans;
    int num_infs;
    int num_large;
    float mean_output;
    float mean_inputs[4];  // means for q, k, v, a
};

class MambaTest {
private:
    // Size constants
    const int total_elements_vo = ATTN_B * ATTN_H * ATTN_N * ATTN_D;
    const int total_elements_qk = ATTN_B * ATTN_G * ATTN_N * ATTN_D;
    const int total_elements_a = ATTN_B * ATTN_H * ATTN_N;

    // Host arrays
    float *q, *k, *v, *a;
    float *output;
    sycl::ext::oneapi::bfloat16 *q_bf, *k_bf, *v_bf, *o_bf;

    // Device arrays
    sycl::ext::oneapi::bfloat16 *d_q, *d_k, *d_v, *d_o;
    float *d_a;

    std::mt19937 rng;

    std::vector<void*> noise_blocks;  // For memory noise
    const size_t NUM_NOISE_BLOCKS = 10;
    const size_t NOISE_BLOCK_SIZE = 1024 * 1024;  // 1MB

    // // Add guard buffers around allocated memory
    // __nv_bfloat16 *d_q_guard_pre, *d_q_guard_post;
    // __nv_bfloat16 *d_k_guard_pre, *d_k_guard_post;
    // __nv_bfloat16 *d_v_guard_pre, *d_v_guard_post;
    // __nv_bfloat16 *d_o_guard_pre, *d_o_guard_post;
    // float *d_a_guard_pre, *d_a_guard_post;
    // static constexpr size_t GUARD_SIZE = 1024;  // Size of guard buffer
    // static constexpr __nv_bfloat16 GUARD_PATTERN = __float2bfloat16(12345.0f);
    // static constexpr float GUARD_PATTERN_FLOAT = 12345.0f;

public:
    MambaTest() : rng(std::random_device{}()) {
        allocateMemory();
        allocateNoiseBlocks();  // Add noise blocks
    }

    ~MambaTest() {
        freeMemory();
        freeNoiseBlocks();  // Clean up noise blocks
    }

     void allocateNoiseBlocks() try {
        for (size_t i = 0; i < NUM_NOISE_BLOCKS; i++) {
            void* ptr = nullptr;
            if (DPCT_CHECK_ERROR(
                    ptr = (void *)sycl::malloc_device(
                        NOISE_BLOCK_SIZE, dpct::get_in_order_queue())) == 0) {
                noise_blocks.push_back(ptr);
            }
        }
    }
     catch (sycl::exception const &exc) {
       std::cerr << exc.what() << "Exception caught at file:" << __FILE__
                 << ", line:" << __LINE__ << std::endl;
       std::exit(1);
     }

    void freeNoiseBlocks() {
        for (void* ptr : noise_blocks) {
            dpct::dpct_free(ptr, dpct::get_in_order_queue());
        }
        noise_blocks.clear();
    }

    void createMemoryPressure() try {
        // Allocate and free memory rapidly
        for (int i = 0; i < 5; i++) {
            void* temp = nullptr;
            if (DPCT_CHECK_ERROR(
                    temp = (void *)sycl::malloc_device(
                        NOISE_BLOCK_SIZE, dpct::get_in_order_queue())) == 0) {
                dpct::dpct_free(temp, dpct::get_in_order_queue());
            }
        }
    }
    catch (sycl::exception const &exc) {
      std::cerr << exc.what() << "Exception caught at file:" << __FILE__
                << ", line:" << __LINE__ << std::endl;
      std::exit(1);
    }

    // Test extreme input values
    void generateExtremeInputs() {
        // Edge cases for inputs
        std::vector<float> test_values = {
            0.0f, 1e-10f, 1e10f,  // Test very small/large values
            std::numeric_limits<float>::min(),
            std::numeric_limits<float>::max(),
            std::nextafter(0.0f, 1.0f),  // Smallest positive float
            -0.0f
        };

        // Apply extreme values at random positions
        std::uniform_int_distribution<int> pos_dist_qk(0, total_elements_qk - 1);
        std::uniform_int_distribution<int> pos_dist_vo(0, total_elements_vo - 1);
        std::uniform_int_distribution<int> pos_dist_a(0, total_elements_a - 1);
        std::uniform_int_distribution<int> val_dist(0, test_values.size() - 1);

        // Insert some extreme values
        for (int i = 0; i < 100; i++) {
            q[pos_dist_qk(rng)] = test_values[val_dist(rng)];
            k[pos_dist_qk(rng)] = test_values[val_dist(rng)];
            v[pos_dist_vo(rng)] = test_values[val_dist(rng)];
            a[pos_dist_a(rng)] = test_values[val_dist(rng)];
        }
    }

    // Add unaligned memory access
    void createMemoryStress() try {
        // Allocate memory blocks of varying sizes
        std::vector<void*> temp_blocks;
        std::vector<size_t> sizes = {1023, 2047, 4095, 8191}; // Unaligned sizes
        
        for (size_t size : sizes) {
            void* ptr = nullptr;
            if (DPCT_CHECK_ERROR(ptr = (void *)sycl::malloc_device(
                                     size, dpct::get_in_order_queue())) == 0) {
                temp_blocks.push_back(ptr);
            }
        }

        // Free in reverse order to create fragmentation
        for (auto it = temp_blocks.rbegin(); it != temp_blocks.rend(); ++it) {
            dpct::dpct_free(*it, dpct::get_in_order_queue());
        }
    }
    catch (sycl::exception const &exc) {
      std::cerr << exc.what() << "Exception caught at file:" << __FILE__
                << ", line:" << __LINE__ << std::endl;
      std::exit(1);
    }

    void allocateMemory() try {
        // Allocate host memory
        q = new float[total_elements_qk];
        k = new float[total_elements_qk];
        v = new float[total_elements_vo];
        a = new float[total_elements_a];
        output = new float[total_elements_vo];

        q_bf = new sycl::ext::oneapi::bfloat16[total_elements_qk];
        k_bf = new sycl::ext::oneapi::bfloat16[total_elements_qk];
        v_bf = new sycl::ext::oneapi::bfloat16[total_elements_vo];
        o_bf = new sycl::ext::oneapi::bfloat16[total_elements_vo];

        // // Allocate device memory
        // CHECK_CUDA(cudaMalloc(&d_q, total_elements_qk * sizeof(__nv_bfloat16)));
        // CHECK_CUDA(cudaMalloc(&d_k, total_elements_qk * sizeof(__nv_bfloat16)));
        // CHECK_CUDA(cudaMalloc(&d_v, total_elements_vo * sizeof(__nv_bfloat16)));
        // CHECK_CUDA(cudaMalloc(&d_o, total_elements_vo * sizeof(__nv_bfloat16)));
        // CHECK_CUDA(cudaMalloc(&d_a, total_elements_a * sizeof(float)));

        // Device memory allocation with immediate initialization
        CHECK_CUDA(DPCT_CHECK_ERROR(
            d_q = sycl::malloc_device<sycl::ext::oneapi::bfloat16>(
                total_elements_qk, dpct::get_in_order_queue())));
        CHECK_CUDA(DPCT_CHECK_ERROR(
            dpct::get_in_order_queue()
                .memset(d_q, 0,
                        total_elements_qk * sizeof(sycl::ext::oneapi::bfloat16))
                .wait()));

        CHECK_CUDA(DPCT_CHECK_ERROR(
            d_k = sycl::malloc_device<sycl::ext::oneapi::bfloat16>(
                total_elements_qk, dpct::get_in_order_queue())));
        CHECK_CUDA(DPCT_CHECK_ERROR(
            dpct::get_in_order_queue()
                .memset(d_k, 0,
                        total_elements_qk * sizeof(sycl::ext::oneapi::bfloat16))
                .wait()));

        CHECK_CUDA(DPCT_CHECK_ERROR(
            d_v = sycl::malloc_device<sycl::ext::oneapi::bfloat16>(
                total_elements_vo, dpct::get_in_order_queue())));
        CHECK_CUDA(DPCT_CHECK_ERROR(
            dpct::get_in_order_queue()
                .memset(d_v, 0,
                        total_elements_vo * sizeof(sycl::ext::oneapi::bfloat16))
                .wait()));

        CHECK_CUDA(DPCT_CHECK_ERROR(
            d_o = sycl::malloc_device<sycl::ext::oneapi::bfloat16>(
                total_elements_vo, dpct::get_in_order_queue())));
        CHECK_CUDA(DPCT_CHECK_ERROR(
            dpct::get_in_order_queue()
                .memset(d_o, 0,
                        total_elements_vo * sizeof(sycl::ext::oneapi::bfloat16))
                .wait()));

        CHECK_CUDA(DPCT_CHECK_ERROR(
            d_a = sycl::malloc_device<float>(total_elements_a,
                                             dpct::get_in_order_queue())));
        CHECK_CUDA(DPCT_CHECK_ERROR(
            dpct::get_in_order_queue()
                .memset(d_a, 0, total_elements_a * sizeof(float))
                .wait()));
    }
    catch (sycl::exception const &exc) {
      std::cerr << exc.what() << "Exception caught at file:" << __FILE__
                << ", line:" << __LINE__ << std::endl;
      std::exit(1);
    }

    void freeMemory() {
        // Free host memory
        delete[] q;
        delete[] k;
        delete[] v;
        delete[] a;
        delete[] output;
        delete[] q_bf;
        delete[] k_bf;
        delete[] v_bf;
        delete[] o_bf;

        // Free device memory
        dpct::dpct_free(d_q, dpct::get_in_order_queue());
        dpct::dpct_free(d_k, dpct::get_in_order_queue());
        dpct::dpct_free(d_v, dpct::get_in_order_queue());
        dpct::dpct_free(d_o, dpct::get_in_order_queue());
        dpct::dpct_free(d_a, dpct::get_in_order_queue());
    }

    // Modified generateInputs to occasionally use extreme values
    void generateInputs() {
        static int counter = 0;
        counter++;

        if (counter % 5 == 0) {  // Every 5th iteration
            generateExtremeInputs();
            return;
        }

        // Original input generation code
        std::uniform_real_distribution<float> dist_qva(0.0f, 1.0f / 10000.0f);
        std::uniform_real_distribution<float> dist_k(0.0f, 1.0f / 100000000.0f);

        for (int i = 0; i < total_elements_qk; i++) {
            q[i] = dist_qva(rng);
            k[i] = dist_k(rng);
        }

        for (int i = 0; i < total_elements_vo; i++) {
            v[i] = dist_qva(rng);
        }

        for (int i = 0; i < total_elements_a; i++) {
            a[i] = dist_qva(rng);
        }

        // Convert to bfloat16 with occasional subnormal numbers
        for (int i = 0; i < total_elements_qk; i++) {
            if (i % 1000 == 0) {  // Occasionally insert subnormal numbers
                q_bf[i] = sycl::ext::intel::math::float2bfloat16(1e-40f);
                k_bf[i] = sycl::ext::intel::math::float2bfloat16(1e-40f);
            } else {
                q_bf[i] = sycl::ext::intel::math::float2bfloat16(q[i]);
                k_bf[i] = sycl::ext::intel::math::float2bfloat16(k[i]);
            }
        }

        for (int i = 0; i < total_elements_vo; i++) {
            if (i % 1000 == 0) {
                v_bf[i] = sycl::ext::intel::math::float2bfloat16(1e-40f);
            } else {
                v_bf[i] = sycl::ext::intel::math::float2bfloat16(v[i]);
            }
        }
    }

    TestResults runIteration() try {
        // createMemoryStress();
        
        TestResults results = {0, 0, 0, 0.0f, {0.0f, 0.0f, 0.0f, 0.0f}};

        // createMemoryPressure();

        // Clear device memory explicitly
        CHECK_CUDA(DPCT_CHECK_ERROR(
            dpct::get_in_order_queue()
                .memset(d_q, 0,
                        total_elements_qk * sizeof(sycl::ext::oneapi::bfloat16))
                .wait()));
        // CHECK_CUDA(cudaMemset(d_k, 0, total_elements_qk * sizeof(__nv_bfloat16)));
        // CHECK_CUDA(cudaMemset(d_v, 0, total_elements_vo * sizeof(__nv_bfloat16)));
        // CHECK_CUDA(cudaMemset(d_a, 0, total_elements_a * sizeof(float)));
        // cudaDeviceSynchronize();
        
        generateInputs();
        
        // Calculate input means
        for (int i = 0; i < total_elements_qk; i++) {
            results.mean_inputs[0] += q[i];
            results.mean_inputs[1] += k[i];
        }
        for (int i = 0; i < total_elements_vo; i++) {
            results.mean_inputs[2] += v[i];
        }
        for (int i = 0; i < total_elements_a; i++) {
            results.mean_inputs[3] += a[i];
        }

        results.mean_inputs[0] /= total_elements_qk;
        results.mean_inputs[1] /= total_elements_qk;
        results.mean_inputs[2] /= total_elements_vo;
        results.mean_inputs[3] /= total_elements_a;

        // Copy data to device
        CHECK_CUDA(DPCT_CHECK_ERROR(
            dpct::get_in_order_queue()
                .memcpy(d_q, q_bf,
                        total_elements_qk * sizeof(sycl::ext::oneapi::bfloat16))
                .wait()));
        CHECK_CUDA(DPCT_CHECK_ERROR(
            dpct::get_in_order_queue()
                .memcpy(d_k, k_bf,
                        total_elements_qk * sizeof(sycl::ext::oneapi::bfloat16))
                .wait()));
        CHECK_CUDA(DPCT_CHECK_ERROR(
            dpct::get_in_order_queue()
                .memcpy(d_v, v_bf,
                        total_elements_vo * sizeof(sycl::ext::oneapi::bfloat16))
                .wait()));
        CHECK_CUDA(DPCT_CHECK_ERROR(
            dpct::get_in_order_queue()
                .memcpy(d_a, a, total_elements_a * sizeof(float))
                .wait()));

        // Run your kernel here
        mamba2_fwd_template::layout::q_global Qg(d_q, ATTN_B, ATTN_G, ATTN_N, nullptr);
        mamba2_fwd_template::layout::k_global Kg(d_k, ATTN_B, ATTN_G, ATTN_N, nullptr);
        mamba2_fwd_template::layout::a_global Ag(d_a, ATTN_B, ATTN_H, nullptr, ATTN_N);
        mamba2_fwd_template::layout::v_global Vg(d_v, ATTN_B, ATTN_H, ATTN_N, nullptr);
        mamba2_fwd_template::layout::o_global Og(d_o, ATTN_B, ATTN_H, ATTN_N, nullptr);


        mamba2_fwd_template::layout::globals globals = {Qg, Kg, Vg, Og, Ag};
        
        unsigned long mem_size = (kittens::MAX_SHARED_MEMORY/2)-2048; // have the flag tell us

        /*
        DPCT1026:586: The call to cudaFuncSetAttribute was removed because SYCL
        currently does not support corresponding setting.
        */

        dpct::get_current_device().queues_wait_and_throw();
        constexpr int NUM_WORKERS = prototype::detail::NUM_CONSUMER_WARPGROUPS_v<mamba2_fwd_template>;
        dpct::dim3 grid(264, 1, 1);
        dpct::get_current_device().queues_wait_and_throw();
        /*
        DPCT1049:413: The work-group size passed to the SYCL kernel may exceed
        the limit. To get the device limit, query
        info::device::max_work_group_size. Adjust the work-group size if needed.
        */
        /*
        DPCT1129:412: The type "typename mamba2_fwd_template::layout::globals"
        is used in the SYCL kernel, but it is not device copyable. The
        sycl::is_device_copyable specialization has been added for this type.
        Please review the code.
        */
        {
            auto exp_props = sycl::ext::oneapi::experimental::properties{
                sycl::ext::oneapi::experimental::use_root_sync};
            dpct::has_capability_or_fail(
                dpct::get_in_order_queue().get_device(), {sycl::aspect::fp16});

            dpct::get_in_order_queue().submit([&](sycl::handler &cgh) {
                sycl::local_accessor<uint8_t, 1> dpct_local_acc_ct1(
                    sycl::range<1>(mem_size), cgh);

                cgh.depends_on(dpct::get_current_device()
                                   .get_in_order_queues_last_events());

                cgh.parallel_for(
                    sycl::nd_range<3>(grid * sycl::range<3>(1, 1, BLOCK_SIZE),
                                      sycl::range<3>(1, 1, BLOCK_SIZE)),
                    exp_props,
                    [=](sycl::nd_item<3> item_ct1) [[sycl::reqd_sub_group_size(
                        32)]] {
                        kittens::prototype::lcsf::kernel<mamba2_fwd_template>(
                            globals,
                            dpct_local_acc_ct1
                                .get_multi_ptr<sycl::access::decorated::no>()
                                .get());
                    });
            });
        }
        dpct::get_current_device().queues_wait_and_throw();

        // Copy results back
        CHECK_CUDA(DPCT_CHECK_ERROR(
            dpct::get_in_order_queue()
                .memcpy(o_bf, d_o,
                        total_elements_vo * sizeof(sycl::ext::oneapi::bfloat16))
                .wait()));

        // Convert output to float and check for NaN/Inf
        float mean_output = 0.0f;
        for (int i = 0; i < total_elements_vo; i++) {
            output[i] = sycl::ext::intel::math::bfloat162float(o_bf[i]);
            if (std::isnan(output[i])) results.num_nans++;
            if (std::isinf(output[i])) results.num_infs++;
            if (output[i] > 1e8) results.num_large++;
            mean_output += output[i];
        }
        results.mean_output = mean_output / total_elements_vo;

        return results;
    }
    catch (sycl::exception const &exc) {
      std::cerr << exc.what() << "Exception caught at file:" << __FILE__
                << ", line:" << __LINE__ << std::endl;
      std::exit(1);
    }
};

int main() {
    try {
        MambaTest test;
        int total_nans = 0;
        int total_infs = 0;

        std::cout << "Starting " << NUM_ITERATIONS << " test iterations..." << std::endl;
        
        for (int i = 0; i < NUM_ITERATIONS; i++) {
            TestResults results = test.runIteration();

            // check that the inputs have no nans or inf means
            // int normal_inputs = ( results.mean_inputs[0] > 0.0f && results.mean_inputs[0] < 1.0f ) &&
            //                     ( results.mean_inputs[1] > 0.0f && results.mean_inputs[1] < 1.0f ) &&
            //                     ( results.mean_inputs[2] > 0.0f && results.mean_inputs[2] < 1.0f ) &&
            //                     ( results.mean_inputs[3] > 0.0f && results.mean_inputs[3] < 1.0f );
            if ( (results.mean_output > 1e8 || results.num_nans > 0 ) ) {
                std::cout << "Iteration " << i << ":\n"
                        << "  NaNs: " << results.num_nans
                        << ", Large: " << results.num_large
                        << ", Infs: " << results.num_infs << "\n"
                        << "  Mean Q: " << results.mean_inputs[0]
                        << ", Mean K: " << results.mean_inputs[1]
                        << ", Mean V: " << results.mean_inputs[2]
                        << ", Mean A: " << results.mean_inputs[3] << "\n"
                        << "  Mean Output: " << results.mean_output << std::endl;
            }
                
            total_nans += results.num_nans;
            total_infs += results.num_infs;
        }

        std::cout << "\nTest Summary:\n"
                 << "Total NaNs: " << total_nans << "\n"
                 << "Total Infs: " << total_infs << "\n"
                 << "Success rate: " 
                 << (NUM_ITERATIONS - (total_nans > 0 || total_infs > 0)) 
                 << "/" << NUM_ITERATIONS << std::endl;

    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    }

    return 0;
}